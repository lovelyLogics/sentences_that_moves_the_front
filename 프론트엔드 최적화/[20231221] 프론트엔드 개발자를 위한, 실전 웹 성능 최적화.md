<aside>
💡 인프런 강의 프론트엔드 개발자를 위한, 실전 웹 성능 최적화(feat. React) - Part. 1의 핵심 내용을 필사한 페이지입니다.

</aside>

### 프론트엔드 최적화? 미사여구 다 빼고 두 개만 기억해라. 로딩 성능, 렌더링 성능!

**로딩 성능:** 브라우저에서 정적파일(HTML,CSS,JS문서 등)을 불러올 빠르게 가져오는가? 느리게 가져오고 있다면 최적화를 못한거다. 그러므로, 프론트엔드는 어떻게 하면 정적파일을 빠르게 가져올 수 있을지 방법을 논의하는 것이 프론트엔드 최적화를 하는 것이다.

**렌더링 성능:** 정적파일을 빠르게 가져왔다 한들, 브라우저에서 느리게 그려지면 소비자가 얼마나 답답하겠는가? 그순간 최적화 실패다. 그러므로, 빠르게 가져온 정적파일을 빠르게 브라우저에 그려주는 것이 프론트엔드 최적화를 하는 것이다.

그렇다면, 로딩성능 최적화를 한다는 것 렌더링 성능을 최적화 한다는 것은 구체적으로 무엇을 하는건가? 아래 사진을 보자!

로딩 성능 최적화를 구성하는 요소는 ‘이미지 사이즈 최적화’ ’Code Split’ ‘텍스트 압축’이 있고, 렌더링 성능 최적화를 구성하는 요소는 ‘Bottleneck 코드 최적화’로 이뤄져있다. 이미지 사이즈 최적화부터 구체적으로 무슨 내용인지 살펴보자.

### 1. 이미지 사이즈 최적화

현재 이용하려는 웹사이트에서 가로 100픽셀, 세로 100픽셀 이미지가 필요한데, DB에 있는 이미지의 원본이 가로 1000px 세로 1000px이라면 해당 사진을 압축하는 과정을 거쳐야한다. 하지만, 이용하려는 웹사이트에서 딱 필요한 사이즈만큼 준다면 압축할 필요 없이 바로 웹사이트에 보여주면 되므로, 그려지는 속도가 빨라질 것이다. 그러므로, 브라우저에서 DB로부터 이미지를 가져오는 중간 과정에이미지 CDN(콘텐츠 중간 저장소)을 두고, 거기서 브라우저에서 필요한 사이즈로 조정하는 로직을 심어두면 브라우저는 이미지를 가져오자 마자 바로 그려내면 되는거다!

출처- 인프런 강의 프론트엔드 개발자를 위한, 실전 웹 성능 최적화(feat. React) - Part. 1

<br>

[🔮이미지 최적화 추천 아티클](https://velog.io/@hustle-dev/%EC%9B%B9-%EC%84%B1%EB%8A%A5%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B5%9C%EC%A0%81%ED%99%94)

### 2. bottleneck 코드 탐색 3. bottleneck 코드 최적화

<img src="https://github.com/lovelyLogics/sentences_that_moves_the_front/assets/81069470/4ddeb90f-1108-4bc6-bf10-123ddedbb40f"/>

크롬 콘솔로그에 있는 lighthouse를 이용해서 현재 웹에 대한 성능이 몇점인지 검사를 받는다. 점수 밑에는 점수가 감점된 원인도 리스트식으로 보여준다. 그 피드백에 대한 내용 대부분이 자바스크립트 관련 내용인데, 구체적으로 어떤 호출이 잘못한 건지는 알려주지 않는다. 라이트 하우스 검사의 한계다. 그럴때는 크롬 콘솔로그에 performance 탭을 들어간다.

<img src="https://github.com/lovelyLogics/sentences_that_moves_the_front/assets/81069470/b9452e16-d0b9-456a-8cf0-a3c75a3bfec6"/>

해당 탭에서는 화면이 로딩된 후 화면을 그리는 과정에서 문서 및 자바스크립트 번들파일을 받아오는 시점부터, 자바스크립트의 호출과 컴포넌트가 렌더링 되는 과정을 시간순으로 색깔막대를 이용해서 보여준다.

<img src="https://github.com/lovelyLogics/sentences_that_moves_the_front/assets/81069470/3d242c1d-9aa5-4240-bf78-01078d495def"/>

해당 사진은 강사님이 블로그의 performance 탭을 보여준건데, 확대해서 보면 Article이라는 컴포넌트 및 네트워크 호출이 오랜시간 지속돼있고, 더 확대해서 들여다보면 removeSpecialCharacter이라는 함수가 연속해서 호출되고 있는 것을 볼 수 있다. 성능 감점의 이유가 해당 함수에 있던 것이다!

이런 과정으로 라이트하우스를 통한 성능 검사 → 피드백 확인 → 퍼포먼스 탭 확인을 통해서 불필요하게 호출이 장시간 유지되는 것 컴포넌트 및 함수들을 찾을 수 있고, 이제 개발자는 그 문제의 컴포넌트 및 함수를 코드단에서 리팩토링해주면 된다!

## 4. bundle 파일 분석 5. Code Splitting & Lazy Loading

### bundle 파일분석

perfomance tab에서 bundle파일을 분석해보자. *bundle이란? 여러 개의 자바스크립트 파일을 하나의 파일로 묶는 작업을 의미한다. 아래 사진에 보이는 0.chunk.js 자바스크립트 번들 파일은 다른 자바스크립트 번들 파일보다 유독 길게 표시되어있다. 하단 Summary탭에서 확인해보니 용량이 995KB라는 것을 확인 할 수 있다. 즉, 자바스크립트 다운로드 시간이 길어질수록 사용자에게 화면을 보여지는 시간이 오래 걸린다.

<img src="https://github.com/lovelyLogics/sentences_that_moves_the_front/assets/81069470/67e2932c-e545-4037-874b-0f6da5074dbc"/>

그렇다면, 저 번들 파일을 어떻게 최적화 할 수 있을까?

1.  **cra-bundle-analyzer를 다운받아서 해당 번들파일을 분석해본다.**

[https://www.npmjs.com/package/cra-bundle-analyzer](https://www.npmjs.com/package/cra-bundle-analyzer)

<img src="https://github.com/lovelyLogics/sentences_that_moves_the_front/assets/81069470/20447237-1fcb-49f0-baa0-83803fe2d518"/>

<img src="https://github.com/lovelyLogics/sentences_that_moves_the_front/assets/81069470/165681df-32dd-4e0d-8a1c-955789485b7c"/>

노란색 표시 부분은 0.chunk.js 파일을 의미한다. (build할 때마다 이름은 달라진다)

하늘색으로 크게 그린 부분은 node_modules안에 들어있는 라이브러리 코드이다.

0.chunk.js 파일에 반을 refractor가 차지하고 있다. 어디서 사용되고 있는지 알기 위해 package-lock-json 파일을 살펴보자.

-   package-lock 파일이란? **`package-lock.json`** 파일은 Node.js 프로젝트에서 사용되는 중요한 파일로, 프로젝트에 사용된 npm 패키지들의 정확한 버전 정보를 기록합니다. 이 파일은 **`npm install`**을 실행할 때 자동으로 생성되며, 프로젝트에서 사용하는 모든 npm 패키지들과 그 의존성(하위 디펜던시)의 구체적인 버전을 정확하게 기록합니다. (챗 gpt 답변)

<img src="https://github.com/lovelyLogics/sentences_that_moves_the_front/assets/81069470/ce06c454-ce5c-45ad-8b39-9bb74f221b87"/>

package-lock 파일에서 refractor을 찾을 수 있다. 현재 이 라이브러리는 상세 디테일 페이지를 들어갔을때 필요한 라이브러리이다. 상위 리스트 컴포넌트에서는 사용되지 않고 있다. 결국, 이 라이브러리를 사용하는 페이지에서 모듈을 다운로드 한다면 번들 파일을 줄일 수 있다. !!! 코드를 분리시켜 모듈이 필요할 때 번들 파일을 받을 수 있게 리팩토링 해보자.

### 1-9. Code Splitting & Lazy Loading

*code splitting이란? 불필요하거나 중복되는 코드를 제거하고, 필요한 코드만 적절한 시점에 로드하여 웹 애플리케이션의 성능을 최적화하는 기법이다. 이를 통해 로딩 시간이 단축되고 사용자 경험이 개선된다.

**Route-based code splitting**

리액트에서 효율적으로 코드를 분할하려면, 라우트를 활용하는 것이 좋다. 페이지 전환 시 발생하는 로딩 시간에 맞춰 **`React.lazy`**와 **`React Router`**를 사용하면, 페이지 로딩을 개선하고 사용자 경험을 향상시키는 라우트 기반 코드 분할을 효과적으로 구현할 수 있다.

출처: 리액트 공식문서 코드 분할 [https://ko.legacy.reactjs.org/docs/code-splitting.html](https://ko.legacy.reactjs.org/docs/code-splitting.html)

```tsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./routes/Home')); //동적으로 필요할 때 로드하겠다!
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>//컴포넌트가 로드되고 있을 때 보여준다.
      <Routes>
        <Route path="/" element={<Home />} /> //이 주소로 접속을 했을 때 Home 컴포넌트가 로드된다!
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
);

```

*** 참고로 CSR(Client-Side Rendering)에서 초기 로딩 속도가 느려지는 주된 이유는 필요한 모든 자바스크립트를 처음에 불러오기 때문이다. 이 문제는 Code Splitting을 통해 해결할 수 있는데, Next.js는 이 기능을 자동으로 제공한다. Next.js는 기본적으로 서버 컴포넌트들에 대해 Code Splitting을 수행하며, streaming을 이용해 서버에서 클라이언트로 UI 조각들을 점진적으로 전송한다.