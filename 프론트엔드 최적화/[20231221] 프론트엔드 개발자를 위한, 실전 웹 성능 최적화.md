<aside>
💡 인프런 강의 프론트엔드 개발자를 위한, 실전 웹 성능 최적화(feat. React) - Part. 1의 핵심 내용을 필사한 페이지입니다.

</aside>

### 프론트엔드 최적화? 미사여구 다 빼고 두 개만 기억해라. 로딩 성능, 렌더링 성능!

**로딩 성능:** 브라우저에서 정적파일(HTML,CSS,JS문서 등)을 불러올 빠르게 가져오는가? 느리게 가져오고 있다면 최적화를 못한거다. 그러므로, 프론트엔드는 어떻게 하면 정적파일을 빠르게 가져올 수 있을지 방법을 논의하는 것이 프론트엔드 최적화를 하는 것이다.

**렌더링 성능:** 정적파일을 빠르게 가져왔다 한들, 브라우저에서 느리게 그려지면 소비자가 얼마나 답답하겠는가? 그순간 최적화 실패다. 그러므로, 빠르게 가져온 정적파일을 빠르게 브라우저에 그려주는 것이 프론트엔드 최적화를 하는 것이다.

그렇다면, 로딩성능 최적화를 한다는 것 렌더링 성능을 최적화 한다는 것은 구체적으로 무엇을 하는건가? 아래 사진을 보자!

로딩 성능 최적화를 구성하는 요소는 ‘이미지 사이즈 최적화’ ’Code Split’ ‘텍스트 압축’이 있고, 렌더링 성능 최적화를 구성하는 요소는 ‘Bottleneck 코드 최적화’로 이뤄져있다. 이미지 사이즈 최적화부터 구체적으로 무슨 내용인지 살펴보자.

### 1. 이미지 사이즈 최적화

현재 이용하려는 웹사이트에서 가로 100픽셀, 세로 100픽셀 이미지가 필요한데, DB에 있는 이미지의 원본이 가로 1000px 세로 1000px이라면 해당 사진을 압축하는 과정을 거쳐야한다. 하지만, 이용하려는 웹사이트에서 딱 필요한 사이즈만큼 준다면 압축할 필요 없이 바로 웹사이트에 보여주면 되므로, 그려지는 속도가 빨라질 것이다. 그러므로, 브라우저에서 DB로부터 이미지를 가져오는 중간 과정에이미지 CDN(콘텐츠 중간 저장소)을 두고, 거기서 브라우저에서 필요한 사이즈로 조정하는 로직을 심어두면 브라우저는 이미지를 가져오자 마자 바로 그려내면 되는거다!

출처- 인프런 강의 프론트엔드 개발자를 위한, 실전 웹 성능 최적화(feat. React) - Part. 1

<br>

[🔮이미지 최적화 추천 아티클](https://velog.io/@hustle-dev/%EC%9B%B9-%EC%84%B1%EB%8A%A5%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B5%9C%EC%A0%81%ED%99%94)

### 2. bottleneck 코드 탐색 3. bottleneck 코드 최적화

![enter image description here](https://lh3.googleusercontent.com/pw/ABLVV85fjkYvE4kH39WVivcODar5wn5hwvj-fCIZ0ZYN-mT9BpIi66cgwLJ0umF8t5qVEySqPkhaZCymuPowtaH6fefxXkLbW0-HtRDFxXnZXSP50aurq1aU7PmLr6gSdLyLA3eUwdW1EIOUr9W8eXLCD_WPMx2p_V0zVrzuYBqpf2dn-fxa4j4HoZBxy7PRp3bVMncCezk_DfwiLiv9X65VTUw8WWuTA4a93W1zkGWbqf9JSV1eUiIlktDYDuIWfPe-FWWZAHQRR9ynvPqVKBZxBSeo5kE3DuMSENlpsAqG7TkjR4-Ev0JszA0oXbqITqy5KmGeMRZrJiloLm9XgU6X07-N-fvIHVemCMPQGmnc9VnWV8gv7Bod8yISsj5FQ6n29Z1uvMOgXv2HvhlDCSUo0tevIa6Ckqf2dDdKatPcdHp2nX3PBiVroe5GQ7MVXV111euScxOPJo7n_i2qYrz0sd_oybeJ4qOL4cZfQRXbOvwr9CXMk0rxnc6YtfS9YHE0fZMHFvpoUNnpcfE6MWA6lEYz5JgBVCsh-qDk_C3tL_hHkaC5bI41rwqtEpJFsqTNw0uzMJG1gET5x3Uj-Sukqx1zZ4VQGp5kBJ9H4YFh-HDwMhSk8wUBTPX1-q-jolPXB-hRUiqz__mjHPsWDotNM6L5l12jUJI9zDQBee9qLWYgAwdCGstTITZEhgxE8SRpBGqDXTg7pwoinClND8-wK1xKH1Y5GHjMkCi63YaeLFOLJUU0RggpXZmPTEs7qRhuO5ohNFOTkiYNYQaxwf1Dn-gsYA_OGHkEjN0dOIpKI8_r16WRptX6WO4H0FxqyafQAxEA1isqNxpl04H3L9xBpr3wgej5RCljP4g06q_WEj7t1sILuD2JbmRE1SlsIkKK=w1513-h1129-s-no-gm?authuser=0)
크롬 콘솔로그에 있는 lighthouse를 이용해서 현재 웹에 대한 성능이 몇점인지 검사를 받는다. 점수 밑에는 점수가 감점된 원인도 리스트식으로 보여준다. 그 피드백에 대한 내용 대부분이 자바스크립트 관련 내용인데, 구체적으로 어떤 호출이 잘못한 건지는 알려주지 않는다. 라이트 하우스 검사의 한계다. 그럴때는 크롬 콘솔로그에 performance 탭을 들어간다.

![enter image description here](https://lh3.googleusercontent.com/pw/ABLVV86KGl2huH_f6Rz_SpwNKPeR9qa_0t4xStjJImJjQ03sdRZB1S_QdZglJmxMCu3muBEiz3iiBYnGLdNqAEvXdIFOw4is5xJmBmBD6wTDIdGCC2rpUjmWxWGw5Xt7KCjKZ6r_rY3k2eIeBx-MCnfGw2Euo7jHlzSvoFhYJhmnhUueXj1oUJDU6PyO_AcosZ0MCGkB-aw6T0OVc1AQkqbe-T0knN_ALXmwf0qEZAmI-yuLgWwLsyaToFZhcFhR15mN3l4KxYGIGP7exS4o5LMHkAt_-Th36esvkVeBYZSCTf-wb6lKvYg37926JH0l_ShsfQ6Mzz0ok5HFtpp8AfTIxsrfFN-m8feycGXKXFU92Hqj7Jw_6ee_AxszijSpDkhY6r1z29luNYIUgd_c4MpL2kvBL3yNr_tgIt_Jnh7OTuMKjguSLDIkLNy51Yny6CysQzk2Ykykjme4T-zFmCSQRXkDEKUhkK8YPKOV7iJym5p8uQEgqzm2v6lHhE-6Dy9pxdvrNPELVQ08V3290-zVfrR_z-4eGolAnQ1HXPBH_4EboaKRBm04O0JD3nFQejJ6xKK7Ye1VJJL5zNfT4trJNNsxZNAlijrS1TMjqvcvGyLNi6xJpm-v60BFBrDXS-ub1utC7eTiOT8XYEqDwj9qU8PssSpPYIkmX1LcjGebBgWYgIkPMIwj_AuxfN_GHe9Nv0_1_uXyx6thWsPnXOvJhr1alxsmOXApQquephaIEc-cS1XmKBK4sUBky2sMkTkaLBaznqrBThDBsTl5n3pmkcFiJVLZ3HPVfnhPBZmSOpTg0rYvS6qPu9q3u3VrBbVVJNw1Bj_Z1_0w3nIFyIKCUw7DOPawU0xzgxLn-pCIAzp0nSeLphV0ohwQ0_B3QHHa=w1411-h1029-s-no-gm?authuser=0)

해당 탭에서는 화면이 로딩된 후 화면을 그리는 과정에서 문서 및 자바스크립트 번들파일을 받아오는 시점부터, 자바스크립트의 호출과 컴포넌트가 렌더링 되는 과정을 시간순으로 색깔막대를 이용해서 보여준다.

![enter image description here](https://lh3.googleusercontent.com/pw/ABLVV84QAv3vP2bbeK5vrVj6z78VWyY8h1bMokbV0M17f17WvalQTtbk4psVfFkmbS8nHlW2w0LlaA5SYnQ6jg4UZkKJNKyFfXPBzdXjKJZgyepmgOsTx08wRgCro0aS2jcWCtC2ybGBNcwvAPWLgdGUHYD1xAhWkz5juo3x-IvUbE2CkrJif7nXY-Vvk4aDgOEFOxjft8uV1_yAhSabPi51k9gTZP2FuLxCkslpA1_d2xAUKPPPBHqrQgyOzs55WFt55fj7ilJyUJM8nbBZKVgfbEYnjsdTMt_yuzbohqTAYYj3_NnHgUyuzwXwQAm1T6Gg20l0Wwfo8EVG-gBcwQjjGO_VR_rDfl4ZdPnknMM-x6IFBxCJgeUBC90h-2tG2ojP_GBu7g8IMUKGacMTJcyvc4uXsg-V8gqkqXXHIjpZ0_9W5wvBxUdsfomyWDzcZdtB-Er6cK0s5SNshAdRghOzjFbkBdoaJX0kcBAov3H5GD2BXQ8q9ru416uyzRx4IRuW4a2t3ZEHCf2aCecmikjH4h8dVIRunKsevOCj4NvAwzB93QMGxJRCocZ7S1MjL46GoNPiUlZ3DJA21fCyXHWcbs8P7m6LApv_emdf5aaSRDxav2-All5-cW__w-KSVIrqKjj2GPFhv_mlXp1XpkHxUThPhVWj8H8hTZ-fpqKRfQjI-209k_U6RtMUyjdcC0g3HfQSk9X5Mn3l-Nih7fl7pyljbb8lzurYfBd1aeCKVETHpiPtTguhLJXlL003zVxzovTPbMLg2p1zZeSkOMJ4dCkIzEnNlo_GRDQ2ZeEaY5NQRlmTZDQoQEkCFh3O_RR0_MD1WRwiGY5bXpoCB2-p6firB_zS1YfJTn762b2GWCKZs0VLKYPP3g2GFE6IM3zs=w1866-h1200-s-no-gm?authuser=0)
해당 사진은 강사님이 블로그의 performance 탭을 보여준건데, 확대해서 보면 Article이라는 컴포넌트 및 네트워크 호출이 오랜시간 지속돼있고, 더 확대해서 들여다보면 removeSpecialCharacter이라는 함수가 연속해서 호출되고 있는 것을 볼 수 있다. 성능 감점의 이유가 해당 함수에 있던 것이다!

이런 과정으로 라이트하우스를 통한 성능 검사 → 피드백 확인 → 퍼포먼스 탭 확인을 통해서 불필요하게 호출이 장시간 유지되는 것 컴포넌트 및 함수들을 찾을 수 있고, 이제 개발자는 그 문제의 컴포넌트 및 함수를 코드단에서 리팩토링해주면 된다!
